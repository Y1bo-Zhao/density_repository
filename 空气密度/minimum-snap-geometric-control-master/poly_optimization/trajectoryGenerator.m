function traj_obj = trajectoryGenerator(map_colli, path)

% Original path generated by djikstra has number of waypoints depends on
% the resolution. Optimal path is chosen by discarding some points which
% doesn't intersect with an obstacle by plotting a line between two points
path = optimalPath_sw(map_colli, path);

% penalty on time; bigger the penalty, faster the movement.
gamma = 500;

% Initial guess: Time intervals are chosen randomly between 1s ~ 3s
tau_vec = rand(1,size(path,1)-1)*2+1;
traj_obj = MinimumSnapTrajectory(tau_vec, path);

% time_allocation
epsilon_t = 1e-8; % epsilon for numerical gradient

count = 1;
while count ~= 0
    
    disp('Time allocation started...')
%     J_grad = costJacobian(traj_obj, gamma, epsilon_t);
    i = 1;
    J_seq = [];
    while 1
        J_grad = costJacobian(traj_obj, gamma, epsilon_t);
        alpha = .000001;
        step = 2;
        J_test = [];
        for m=1:500
            tau_vec_test = tau_vec - J_grad/norm(J_grad)*alpha*step^(m-1);
            if find(tau_vec_test<0)
                disp('tau vector cannot have negative values.')
                break
            end
            J_test = [J_test computeCost(traj_obj, gamma)];

            % If the latest cost is larger then previous one, escape the loop
            [~, minidx] = min(J_test);
            if minidx ~= length(J_test)
                break
            end
        end
        [minval, minidx] = min(J_test);
        % update tau
        tau_vec = tau_vec - J_grad/norm(J_grad)*alpha*step^(minidx-1);
        % If cost does not change more than 1% for 5 times, we assume it
        % reaches to the minimum.
        J_seq = [J_seq minval];
        i = i+1;
        if i == 5
            if ~any(abs(J_seq - J_seq(end))./J_seq(end) > .001)
                break
            end
            i = 1;
            J_seq = [];
        end
    end
disp('Time allocation finished')

%%%%%%%%%%%%%%%%%%%% Hessian %%%%%%%%%%%%%%%%%%%%%% not working yet
% epsilon_t = 1e-8;
% J_grad = gradient_J(tau_vec, PATH, gamma, epsilon_t);
% epsilon_J = 1e-3;
% J_hess = hessian_J(tau_vec, PATH, gamma, epsilon_J);
% tau_vec = tau_vec - (J_hess\J_grad')'
% tau_vec = abs(tau_vec);
% J = costFunc_appA(tau_vec, PATH, sum(tau_vec), gamma)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% not working yet

traj_obj = MinimumSnapTrajectory(tau_vec, path);
fprintf('Number of way points: %i\n', length(path))
% Check collision
X_test = [];
PATH_test = path;
count = 0;
    for i=1:length(tau_vec) % # of segments
        for ii = 1:size(path,2) % x,y,z
            X_test(:,ii) = polyval(traj_obj.P(10*i:-1:10*(i-1)+1,ii),linspace(0,tau_vec(i),50));
        end
        if any(collide(map_colli, X_test(2:end-1,:)))
            disp('Collision detected')
            interm_pt = (PATH_test(i+count,:) + PATH_test(i+count+1,:))./2;
            int2end_path = [interm_pt; PATH_test(i+count+1:end,:)];
            optimal_int2end = optimalPath_sw(map_colli, int2end_path);
%             PATH_test = [PATH_test(1:i+count,:); interm_pt; PATH_test(i+count+1:end,:)];
            PATH_test = [PATH_test(1:i+count,:); optimal_int2end];
            count = count+1;
            tau_vec = [tau_vec(1:i-1), rand(1,size(PATH_test,1)-1-(i-1))*2+1];
            path = PATH_test;
            traj_obj = MinimumSnapTrajectory(tau_vec, path);
            disp('New path made')
            break
        end
    end

end
disp('Collision-free trajectory generated')
disp('Finished')
J = computeCost(traj_obj, gamma);
fprintf('Final cost: %d\n', J)

% Plot trajectory in piecewise (different colors)
K = length(tau_vec);
ttt = [];
ttt = [ttt, linspace(0,tau_vec(1),50)];
for i=2:K
    ttt = [ttt, sum(tau_vec(1:i-1)) + linspace(0,tau_vec(i),50)];
end
X = [];
XX = [];
for i=1:length(tau_vec) % # of segments
    for ii = 1:size(path,2)
        X(:,ii) = polyval(traj_obj.P(10*i:-1:10*(i-1)+1,ii),linspace(0,tau_vec(i),50));
    end
    XX = [XX;X];
    if size(path,2) == 3
        figure(1);
        hold on
        grid on
        axis equal
        plot3(X(:,1),X(:,2),X(:,3),'LineWidth',1.5)
    end
end
hold off
end

